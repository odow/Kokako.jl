<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics I: first steps · Kokako.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Kokako.jl logo"/></a><h1>Kokako.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li class="current"><a class="toctext" href>Basics I: first steps</a><ul class="internal"><li><a class="toctext" href="#Mathematical-formulation-1">Mathematical formulation</a></li><li><a class="toctext" href="#Creating-a-Kokako-model-1">Creating a Kokako model</a></li><li><a class="toctext" href="#Training-a-Kokako-policy-1">Training a Kokako policy</a></li><li><a class="toctext" href="#Simulating-the-policy-1">Simulating the policy</a></li></ul></li><li><a class="toctext" href="../02_adding_uncertainty/">Basics II: adding uncertainty</a></li><li><a class="toctext" href="../03_objective_uncertainty/">Basics III: objective uncertainty</a></li><li><a class="toctext" href="../04_markov_uncertainty/">Basics IV: Markov uncertainty</a></li><li><a class="toctext" href="../05_plotting/">Basics V: plotting</a></li><li><a class="toctext" href="../06_warnings/">Basics VI: words of warning</a></li><li><a class="toctext" href="../11_risk/">Intermediate I: risk</a></li><li><a class="toctext" href="../12_stopping_rules/">Intermediate II: stopping rules</a></li><li><a class="toctext" href="../13_generic_graphs/">Intermediate III: policy graphs</a></li><li><a class="toctext" href="../14_price_interpolation/">Intermediate IV: price interpolation</a></li><li><a class="toctext" href="../15_performance/">Intermediate V: performance</a></li></ul></li><li><a class="toctext" href="../../apireference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Basics I: first steps</a></li></ul><a class="edit-page" href="https://github.com/odow/Kokako.jl/blob/master/docs/src/tutorial/01_first_steps.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Basics I: first steps</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basics-I:-first-steps-1" href="#Basics-I:-first-steps-1">Basics I: first steps</a></h1><p>Hydrothermal scheduling is the most common application of stochastic dual dynamic programming. To illustrate some of the basic functionality of <code>Kōkako.jl</code>, we implement a very simple model of the hydrothermal scheduling problem.</p><p>We consider the problem of scheduling electrical generation over three time periods in order to meet a known demand of 150 MWh in each period.</p><p>There are two generators: a thermal generator, and a hydro generator. The thermal generator has a short-run marginal cost of \$50/MWh in the first stage, \$100/MWh in the second stage, and \$150/MWh in the third stage. The hydro generator has a short-run marginal cost of \$0/MWh.</p><p>The hydro generator draws water from a reservoir which has a maximum capacity of 200 units. We assume that at the start of the first time period, the reservoir is full. In addition to the ability to generate electricity by passing water through the hydroelectric turbine, the hydro generator can also spill water down a spillway (bypassing the turbine) in order to prevent the water from over-topping the dam. We assume that there is no cost of spillage.</p><p>The objective of the optimization is to minimize the expected cost of generation over the three time periods.</p><h2><a class="nav-anchor" id="Mathematical-formulation-1" href="#Mathematical-formulation-1">Mathematical formulation</a></h2><p>Let&#39;s take the problem described above and form a mathematical model. In any multistage stochastic programming problem, we need to identify five key features:</p><ol><li>The <em>stages</em></li><li>The <em>state</em> variables</li><li>The <em>control</em> variables</li><li>The <em>dynamics</em></li><li>The <em>stage-objective</em></li></ol><h4><a class="nav-anchor" id="Stages-1" href="#Stages-1">Stages</a></h4><blockquote><p>We consider the problem of scheduling electrical generation over three time</p></blockquote><p>periods</p><p>So, we have three stages: <code>t = 1, 2, 3</code>. Here is a picture:</p><p><img src="../../assets/deterministic_linear_policy_graph.png" alt="Linear policy graph"/></p><p>Notice that the boxes form a <em>linear graph</em>. This will be important when we get to the code. (We&#39;ll get to more complicated graphs in future tutorials.)</p><h4><a class="nav-anchor" id="State-variables-1" href="#State-variables-1">State variables</a></h4><p>State variables capture the information that flows between stages. These can be harder to identify. However, in our model, the state variable is the volume of water stored in the reservoir over time.</p><p>In the model below, we&#39;re going to call the state variable <code>volume</code>.</p><p>Each stage <code>t</code> is an interval in time. Thus, we need to record the value of the state variable in each stage at two points in time: at the beginning of the stage, which we  refer to as the <em>incoming</em> value of the state variable; and at the end of the  state, which we refer to as the <em>outgoing</em> state variable.</p><p>We&#39;re going to refer to the incoming value of <code>volume</code> by <code>volume.in</code> and the outgoing value by <code>volume.out</code>.</p><p>Note that <code>volume.out</code> when <code>t=1</code> is equal to <code>volume.in</code> when <code>t=2</code>.</p><p>The problem description also mentions some constraints on the volume of water in the reservoir. It cannot be negative, and the maximum level is 200 units. Thus, we have <code>0 &lt;= volume &lt;= 200</code>. Also, the description says that the initial value of water in the reservoir (i.e., <code>volume.in</code> when <code>t = 1</code>) is 200.</p><h4><a class="nav-anchor" id="Control-variables-1" href="#Control-variables-1">Control variables</a></h4><p>Control variables are the actions that the agent can take during a stage to change the value of the state variables. (Hence the name <em>control</em>.)</p><p>There are three control variables in our problem.</p><ol><li>The quantity of thermal generation, which we&#39;re going to call <code>thermal_generation</code>.</li><li>The quantity of hydro generation, which we&#39;re going to call <code>hydro_generation</code>.</li><li>The quatity of water to spill, which we&#39;re going to call <code>hydro_spill</code>.</li></ol><p>All of these variables are non-negative.</p><h4><a class="nav-anchor" id="The-dynamics-1" href="#The-dynamics-1">The dynamics</a></h4><p>The dynamics of a problem describe how the state variables evolve through time in response to the controls chosen by the agent.</p><p>For our problem, the state variable is the volume of water in the reservoir. The volume of water decreases in response to water being used for hydro generation and spillage. So the dynamics for our problem are:</p><p><code>volume.out = volume.in - hydro_generation - hydro_spill</code></p><p>We can also put constraints on the values of the state and control variables. For example, in our problem, there is also a constraint that the total generation must meet the demand of 150 MWh in each stage. So, we have a constraint that: <code>hydro_generation + thermal_generation = 150</code>.</p><h4><a class="nav-anchor" id="The-stage-objective-1" href="#The-stage-objective-1">The stage-objective</a></h4><p>The agent&#39;s objective is to minimize the cost of generation. So in each stage, the agent wants to minimize the quantity of thermal generation multiplied by the short-run marginal cost of thermal generation.</p><p>In stage <code>t</code>, they want to minimize <code>fuel_cost[t] * thermal_generation</code>, where <code>fuel_cost[t]</code> is \$50 when <code>t=1</code>, \$100 when <code>t=2</code>, and \$150 when <code>t=3</code>.</p><p>We&#39;re now ready to construct a Kokako model. Since Kokako is intended to be very user-friendly, we&#39;re going to give the full code first, and then walk through some of the details. However, you should be able to read through and understand most of what is happening.</p><h2><a class="nav-anchor" id="Creating-a-Kokako-model-1" href="#Creating-a-Kokako-model-1">Creating a Kokako model</a></h2><pre><code class="language-julia">using Kokako, GLPK

model = Kokako.LinearPolicyGraph(
            stages = 3,
            sense = :Min,
            lower_bound = 0.0,
            optimizer = with_optimizer(GLPK.Optimizer)
        ) do subproblem, t
    # Define the state variable.
    @variable(subproblem, 0 &lt;= volume &lt;= 200, Kokako.State, initial_value = 200)
    # Define the control variables.
    @variables(subproblem, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
    end)
    # Define the constraints
    @constraints(subproblem, begin
        volume.out == volume.in - hydro_generation - hydro_spill
        thermal_generation + hydro_generation == 150.0
    end)
    # Define the objective for each stage `t`. Note that we can use `t` as an
    # index for t = 1, 2, 3.
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(subproblem, fuel_cost[t] * thermal_generation)
end

# output

A policy graph with 3 nodes.
 Node indices: 1, 2, 3</code></pre><p>Wasn&#39;t that easy! Let&#39;s walk through some of the non-obvious features.</p><h4><a class="nav-anchor" id="The-keywords-in-the-[Kokako.LinearPolicyGraph](@ref)-constructor-1" href="#The-keywords-in-the-[Kokako.LinearPolicyGraph](@ref)-constructor-1">The keywords in the <a href="../../apireference/#Kokako.LinearPolicyGraph"><code>Kokako.LinearPolicyGraph</code></a> constructor</a></h4><p>Hopefully <code>stages</code> and <code>sense</code> are obvious. However, the other two are not so clear.</p><p><code>lower_bound</code>: you <em>must</em> supply a valid bound on the objective. For our problem, we know that we cannot incur a negative cost so \$0 is a valid lower bound.</p><p><code>optimizer</code>: This is borrowed directly from JuMP&#39;s <code>Model</code> constructor:</p><pre><code class="language-julia">using JuMP
model = Model(with_optimizer(GLPK.Optimizer))</code></pre><h4><a class="nav-anchor" id="Creating-state-variables-1" href="#Creating-state-variables-1">Creating state variables</a></h4><p>State variables can be created like any other JuMP variables. Think of them as another type of variable like binary or integer. For example, to create a binary variable in JuMP, you go:</p><pre><code class="language-julia">@variable(subproblem, x, Bin)</code></pre><p>whereas to create a state variable you go</p><pre><code class="language-julia">@variable(subproblem, x, Kokako.State)</code></pre><p>Also note that you have to pass a keyword argument called <code>initial_value</code> that gives the incoming value of the state variable in the first stage.</p><h4><a class="nav-anchor" id="Defining-the-stage-objective-1" href="#Defining-the-stage-objective-1">Defining the stage-objective</a></h4><p>In a JuMP model, we can set the objective using <code>@objective</code>. For example:</p><pre><code class="language-julia">@objective(subproblem, Min, fuel_cost[t] * thermal_generation)</code></pre><p>Since we only need to define the objective for each stage, rather than the whole problem, we use the Kokako-provided <a href="../../apireference/#Kokako.@stageobjective"><code>@stageobjective</code></a>.</p><pre><code class="language-julia">@stageobjective(subproblem, fuel_cost[t] * thermal_generation)</code></pre><p>Note that we don&#39;t have to specify the optimization sense (<code>Max</code> of <code>Min</code>) since this is done via the <code>sense</code> keyword argument of <a href="../../apireference/#Kokako.LinearPolicyGraph"><code>Kokako.LinearPolicyGraph</code></a>.</p><h2><a class="nav-anchor" id="Training-a-Kokako-policy-1" href="#Training-a-Kokako-policy-1">Training a Kokako policy</a></h2><p>Kokako models can be trained using the <a href="../../apireference/#Kokako.train"><code>Kokako.train</code></a> function. It accepts a number of keyword arguments. <code>iteration_limit</code> terminates the training after the provided number of iterations.</p><p><a href="../../apireference/#Kokako.train"><code>Kokako.train</code></a> returns a <code>TrainingResults</code> object. You can query the reason that the training stopped by calling <a href="../../apireference/#Kokako.termination_status"><code>Kokako.termination_status</code></a> on this  object.</p><pre><code class="language-julia">training_results = Kokako.train(model; iteration_limit = 3)

println(&quot;Termination status is: &quot;, Kokako.termination_status(training_results))

# output

———————————————————————————————————————————————————————————————————————————————
                        Kokako - © Oscar Dowson, 2018-19.
———————————————————————————————————————————————————————————————————————————————
 Iteration | Simulation |      Bound |   Time (s)
———————————————————————————————————————————————————————————————————————————————
         1 |    32.500K |    15.000K |     0.001
         2 |    17.500K |    17.500K |     0.002
         3 |    17.500K |    17.500K |     0.002
Termination status is: iteration_limit</code></pre><h2><a class="nav-anchor" id="Simulating-the-policy-1" href="#Simulating-the-policy-1">Simulating the policy</a></h2><p>Once you have a trained policy, you can simulate it using <a href="../../apireference/#Kokako.simulate"><code>Kokako.simulate</code></a>. The return value from <code>simulate</code> is a vector with one element for each replication. Each element is itself a vector, with one element for each stage. Each element, corresponding to a particular stage in a particular replication, is a dictionary that records information from the simulation.</p><pre><code class="language-julia">simulations = Kokako.simulate(
    # The trained model to simulate.
    model,
    # The number of replications.
    1,
    # A list of names to record the values of.
    [:volume, :thermal_generation, :hydro_generation, :hydro_spill]
)

replication = 1
stage = 2
simulations[replication][stage]

# output

Dict{Symbol,Any} with 9 entries:
  :volume             =&gt; State{Float64}(200.0, 150.0)
  :hydro_spill        =&gt; 0.0
  :bellman_term       =&gt; 0.0
  :noise_term         =&gt; nothing
  :node_index         =&gt; 2
  :stage_objective    =&gt; 10000.0
  :objective_state    =&gt; nothing
  :thermal_generation =&gt; 100.0
  :hydro_generation   =&gt; 50.0</code></pre><p>Ignore many of the entries for now. They will be relevant later. Of interest is <code>:volume</code> and <code>:thermal_generation</code>.</p><pre><code class="language-julia-repl">julia&gt; outgoing_volume = [stage[:volume].out for stage in simulations[1]]
3-element Array{Float64,1}:
 200.0
 150.0
   0.0

julia&gt; thermal_generation = [stage[:thermal_generation] for stage in simulations[1]]
3-element Array{Float64,1}:
 150.0
 100.0
   0.0</code></pre><p>From this, we can see the optimal policy: in the first stage, use 150 MWh of thermal generation and 0 MWh of hydro generation. In the second stage, use 100 MWh of thermal and 50 Wh of hydro. In the third and final stage, use 0 MWh of thermal and 150 MWh of  hydro.</p><p>This concludes our first very simple tutorial for <code>Kokako.jl</code>. In the next tutorial, <a href="../02_adding_uncertainty/#Basics-II:-adding-uncertainty-1">Basics II: adding uncertainty</a>, we will extend this problem by adding uncertainty.</p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../02_adding_uncertainty/"><span class="direction">Next</span><span class="title">Basics II: adding uncertainty</span></a></footer></article></body></html>
