<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic II: adding uncertainty · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><span class="toctext">Basic</span><ul><li><a class="toctext" href="../01_first_steps/">Basic I: first steps</a></li><li class="current"><a class="toctext" href>Basic II: adding uncertainty</a><ul class="internal"><li><a class="toctext" href="#Creating-a-model-1">Creating a model</a></li><li><a class="toctext" href="#Training-and-simulating-the-policy-1">Training and simulating the policy</a></li></ul></li><li><a class="toctext" href="../03_objective_uncertainty/">Basic III: objective uncertainty</a></li><li><a class="toctext" href="../04_markov_uncertainty/">Basic IV: Markov uncertainty</a></li><li><a class="toctext" href="../05_plotting/">Basic V: plotting</a></li><li><a class="toctext" href="../06_warnings/">Basic VI: words of warning</a></li><li><a class="toctext" href="../07_advanced_modelling/">Basic VII: modelling tips</a></li></ul></li><li><span class="toctext">Intermediate</span><ul><li><a class="toctext" href="../11_risk/">Intermediate I: risk</a></li><li><a class="toctext" href="../12_stopping_rules/">Intermediate II: stopping rules</a></li><li><a class="toctext" href="../13_generic_graphs/">Intermediate III: policy graphs</a></li><li><a class="toctext" href="../14_objective_states/">Intermediate IV: objective states</a></li><li><a class="toctext" href="../15_performance/">Intermediate V: performance</a></li></ul></li></ul></li><li><a class="toctext" href="../../apireference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li>Basic</li><li><a href>Basic II: adding uncertainty</a></li></ul><a class="edit-page" href="https://github.com/odow/Kokako.jl/blob/master/docs/src/tutorial/02_adding_uncertainty.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Basic II: adding uncertainty</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basic-II:-adding-uncertainty-1" href="#Basic-II:-adding-uncertainty-1">Basic II: adding uncertainty</a></h1><p>In the previous tutorial, <a href="../01_first_steps/#Basic-I:-first-steps-1">Basic I: first steps</a>, we created a deterministic  hydro-thermal scheduling model. In this tutorial, we extend the problem by adding uncertainty.</p><p>Notably missing from our previous model were inflows. Inflows are the water that flows into the reservoir through rainfall or rivers. These inflows are uncertain, and are the cause of the main trade-off in hydro-thermal scheduling: the desire to use water now to generate cheap electricity, against the risk that future inflows will be low, leading to blackouts or expensive thermal generation.</p><p>For our simple model, we assume that the inflows can be modelled by a discrete distribution with the three outcomes given in the following table:</p><table><tr><th>ω</th><th>0</th><th>50</th><th>100</th></tr><tr><td>P(ω)</td><td>1/3</td><td>1/3</td><td>1/3</td></tr></table><p>The value of the noise (the random variable) is observed by the agent at the start of each stage. This makes the problem a <em>wait-and-see</em> or <em>hazard-decision</em> formulation.</p><p>To represent this, we can draw the following picture. The wavy lines denote the uncertainty arriving into the start of each stage (node).</p><p><img src="../../assets/stochastic_linear_policy_graph.png" alt="Linear policy graph"/></p><p>In addition to adding this uncertainty to the model, we also need to modify the dynamics to include <code>inflow</code>:</p><p><code>volume.out = volume.in + inflow - hydro_generation - hydro_spill</code></p><h2><a class="nav-anchor" id="Creating-a-model-1" href="#Creating-a-model-1">Creating a model</a></h2><p>To add an uncertain variable to the model, we create a new JuMP variable <code>inflow</code>, and then call the function <a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a>. The <a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a> function takes three arguments: the subproblem, a vector of realizations, and a corresponding vector of probabilities.</p><pre><code class="language-julia">using Kokako, GLPK

model = Kokako.LinearPolicyGraph(
            stages = 3,
            sense = :Min,
            lower_bound = 0.0,
            optimizer = with_optimizer(GLPK.Optimizer)
        ) do subproblem, t
    # Define the state variable.
    @variable(subproblem, 0 &lt;= volume &lt;= 200, Kokako.State, initial_value = 200)
    # Define the control variables.
    @variables(subproblem, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
        inflow
    end)
    # Define the constraints
    @constraints(subproblem, begin
        volume.out == volume.in + inflow - hydro_generation - hydro_spill
        demand_constraint, thermal_generation + hydro_generation == 150.0
    end)
    # Define the objective for each stage `t`. Note that we can use `t` as an
    # index for t = 1, 2, 3.
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(subproblem, fuel_cost[t] * thermal_generation)
    # Parameterize the subproblem.
    Kokako.parameterize(subproblem, [0.0, 50.0, 100.0], [1/3, 1/3, 1/3]) do ω
        JuMP.fix(inflow, ω)
    end
end

# output

A policy graph with 3 nodes.
 Node indices: 1, 2, 3</code></pre><p>Note how we use the JuMP function <a href="http://www.juliaopt.org/JuMP.jl/v0.19/variables/#JuMP.fix"><code>JuMP.fix</code></a> to set the value of the <code>inflow</code> variable to <code>ω</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a> can only be called once in each subproblem definition!</p></div></div><h2><a class="nav-anchor" id="Training-and-simulating-the-policy-1" href="#Training-and-simulating-the-policy-1">Training and simulating the policy</a></h2><p>As in <a href="../01_first_steps/#Basic-I:-first-steps-1">Basic I: first steps</a>, we train the policy:</p><pre><code class="language-julia-repl">julia&gt; Kokako.train(model; iteration_limit = 10)
----------------------------------------------------
         SDDP.jl (c) Oscar Dowson, 2017-19

Numerical stability report
  Non-zero Matrix range     [1e+00, 1e+00]
  Non-zero Objective range  [1e+00, 2e+02]
  Non-zero Bounds range     [2e+02, 2e+02]
  Non-zero RHS range        [2e+02, 2e+02]

 Iteration   Simulation      Bound        Time (s)
         1   2.00000e+04   5.00000e+03   5.74300e+00
         2   5.00000e+03   8.33333e+03   5.77900e+00
         3   7.50000e+03   8.33333e+03   5.78000e+00
         4   7.50000e+03   8.33333e+03   5.78100e+00
         5   7.50000e+03   8.33333e+03   5.78200e+00
         6   7.50000e+03   8.33333e+03   5.78200e+00
         7   1.25000e+04   8.33333e+03   5.78300e+00
         8   1.25000e+04   8.33333e+03   5.78400e+00
         9   7.50000e+03   8.33333e+03   5.78500e+00
        10   2.50000e+03   8.33333e+03   5.78600e+00

Terminating training with status: iteration_limit
----------------------------------------------------</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since SDDP is a stochastic algorithm, you might get slightly different numerical results.</p></div></div><p>We can also simulate the policy. Note that this time, the simulation is stochastic. One common approach to quantify the quality of the policy is to perform  a Monte Carlo simulation and then form a confidence interval for the expected cost. This confidence interval is an estimate for the upper bound.</p><p>In addition to the confidence interval, we can calculate the lower bound using <a href="../../apireference/#Kokako.calculate_bound"><code>Kokako.calculate_bound</code></a>.</p><pre><code class="language-julia-repl">julia&gt; simulations = Kokako.simulate(model, 500);

julia&gt; objective_values = [
           sum(stage[:stage_objective] for stage in sim) for sim in simulations
       ];

julia&gt; using Statistics

julia&gt; μ = round(mean(objective_values), digits = 2);

julia&gt; ci = round(1.96 * std(objective_values) / sqrt(500), digits = 2);

julia&gt; println(&quot;Confidence interval: &quot;, μ, &quot; ± &quot;, ci)
Confidence interval: 8400.00 ± 409.34

julia&gt; println(&quot;Lower bound: &quot;, round(Kokako.calculate_bound(model), digits = 2))
Lower bound: 8333.33</code></pre><p>In addition to simulating the primal values of variables, we can also pass <code>SDDP.jl</code> custom recorder functions. Each of these functions takes one argument, the JuMP subproblem, and returns anything you can compute. For example, the dual of the demand constraint (which we named <code>demand_constraint</code>) corresponds to the price we should charge for electricity, since it represents the cost of each additional unit of demand. To calculate this, we can go</p><pre><code class="language-julia-repl">julia&gt; simulations = Kokako.simulate(
           model,
           1,
           custom_recorders = Dict{Symbol, Function}(
               :price =&gt; (sp) -&gt; JuMP.dual(sp[:demand_constraint])
           )
       );

julia&gt; [stage[:price] for stage in simulations[1]]
3-element Array{Float64,1}:
  50.0
 100.0
  -0.0</code></pre><p>This concludes our second tutorial for <code>SDDP.jl</code>. In the next tutorial, <a href="../03_objective_uncertainty/#Basic-III:-objective-uncertainty-1">Basic III: objective uncertainty</a>, we extend the uncertainty to the fuel cost.</p><footer><hr/><a class="previous" href="../01_first_steps/"><span class="direction">Previous</span><span class="title">Basic I: first steps</span></a><a class="next" href="../03_objective_uncertainty/"><span class="direction">Next</span><span class="title">Basic III: objective uncertainty</span></a></footer></article></body></html>
