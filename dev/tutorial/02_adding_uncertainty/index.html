<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basics II: adding uncertainty · Kokako.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Kokako.jl logo"/></a><h1>Kokako.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../01_first_steps/">Basics I: first steps</a></li><li class="current"><a class="toctext" href>Basics II: adding uncertainty</a><ul class="internal"><li><a class="toctext" href="#Creating-a-Kokako-model-1">Creating a Kokako model</a></li><li><a class="toctext" href="#Training-and-simulating-the-policy-1">Training and simulating the policy</a></li></ul></li><li><a class="toctext" href="../03_objective_uncertainty/">Basics III: objective uncertainty</a></li><li><a class="toctext" href="../04_markov_uncertainty/">Basics IV: Markov uncertainty</a></li><li><a class="toctext" href="../05_plotting/">Basics V: plotting</a></li><li><a class="toctext" href="../06_warnings/">Basics VI: words of warning</a></li></ul></li><li><a class="toctext" href="../../apireference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Basics II: adding uncertainty</a></li></ul><a class="edit-page" href="https://github.com/odow/Kokako.jl/blob/master/docs/src/tutorial/02_adding_uncertainty.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Basics II: adding uncertainty</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Basics-II:-adding-uncertainty-1" href="#Basics-II:-adding-uncertainty-1">Basics II: adding uncertainty</a></h1><p>In the previous tutorial, <a href="../01_first_steps/#Basics-I:-first-steps-1">Basics I: first steps</a>, we created a deterministic  hydro-thermal scheduling model. In this tutorial, we extend the problem by adding uncertainty.</p><p>Notably missing from our previous model were inflows. Inflows are the water that flows into the reservoir through rainfall or rivers. These inflows are uncertain, and are the cause of the main trade-off in hydro-thermal scheduling: the desire to use water now to generate cheap electricity, against the risk that future inflows will be low, leading to blackouts or expensive thermal generation.</p><p>For our simple model, we assume that the inflows can be modelled by a discrete distribution with the three outcomes given in the following table:</p><table><tr><th>ω</th><th>0</th><th>50</th><th>100</th></tr><tr><td>P(ω)</td><td>1/3</td><td>1/3</td><td>1/3</td></tr></table><p>The value of the noise (the random variable) is observed by the agent at the start of each stage. This makes the problem a <em>wait-and-see</em> or <em>hazard-decision</em> formulation.</p><p>To represent this, we can draw the following picture. The wavy lines denote the uncertainty arriving into the start of each stage (node).</p><p><img src="../../assets/stochastic_linear_policy_graph.png" alt="Linear policy graph"/></p><p>In addition to adding this uncertainty to the model, we also need to modify the dynamics to include <code>inflow</code>:</p><p><code>volume.out = volume.in + inflow - hydro_generation - hydro_spill</code></p><h2><a class="nav-anchor" id="Creating-a-Kokako-model-1" href="#Creating-a-Kokako-model-1">Creating a Kokako model</a></h2><p>To add an uncertain variable to the model, we create a new JuMP variable <code>inflow</code>, and then call the function <a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a>. The <a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a> function takes three arguments: the subproblem, a vector of realizations, and a corresponding vector of probabilities.</p><pre><code class="language-julia">using Kokako, GLPK

model = Kokako.LinearPolicyGraph(
            stages = 3,
            sense = :Min,
            lower_bound = 0.0,
            optimizer = with_optimizer(GLPK.Optimizer)
        ) do subproblem, t
    # Define the state variable.
    @variable(subproblem, 0 &lt;= volume &lt;= 200, Kokako.State, initial_value = 200)
    # Define the control variables.
    @variables(subproblem, begin
        thermal_generation &gt;= 0
        hydro_generation   &gt;= 0
        hydro_spill        &gt;= 0
        inflow
    end)
    # Define the constraints
    @constraints(subproblem, begin
        volume.out == volume.in + inflow - hydro_generation - hydro_spill
        demand_constraint, thermal_generation + hydro_generation == 150.0
    end)
    # Define the objective for each stage `t`. Note that we can use `t` as an
    # index for t = 1, 2, 3.
    fuel_cost = [50.0, 100.0, 150.0]
    @stageobjective(subproblem, fuel_cost[t] * thermal_generation)
    # Parameterize the subproblem.
    Kokako.parameterize(subproblem, [0.0, 50.0, 100.0], [1/3, 1/3, 1/3]) do ω
        JuMP.fix(inflow, ω)
    end
end

# output

A policy graph with 3 nodes.
 Node indices: 1, 2, 3</code></pre><p>Note how we use the JuMP function <code>JuMP.fix</code> to set the value of the <code>inflow</code> variable to <code>ω</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><a href="../../apireference/#Kokako.parameterize"><code>Kokako.parameterize</code></a> can only be called once in each subproblem definition!</p></div></div><h2><a class="nav-anchor" id="Training-and-simulating-the-policy-1" href="#Training-and-simulating-the-policy-1">Training and simulating the policy</a></h2><p>As in <a href="../01_first_steps/#Basics-I:-first-steps-1">Basics I: first steps</a>, we train the policy:</p><pre><code class="language-julia">training_results = Kokako.train(model; iteration_limit = 10)

println(&quot;Termination status is: &quot;, Kokako.termination_status(training_results))

# output

———————————————————————————————————————————————————————————————————————————————
                        Kokako - © Oscar Dowson, 2018-19.
———————————————————————————————————————————————————————————————————————————————
 Iteration | Simulation |      Bound |   Time (s)
———————————————————————————————————————————————————————————————————————————————
         1 |    12.500K |     5.000K |     0.007
         2 |    12.500K |     8.333K |     0.007
         3 |    12.500K |     8.333K |     0.008
         4 |    12.500K |     8.333K |     0.009
         5 |     2.500K |     8.333K |     0.011
         6 |     5.000K |     8.333K |     0.012
         7 |     5.000K |     8.333K |     0.013
         8 |    12.500K |     8.333K |     0.014
         9 |     7.500K |     8.333K |     0.014
        10 |     5.000K |     8.333K |     0.016
Termination status is: iteration_limit</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since SDDP is a stochastic algorithm, you might get slightly different numerical results.</p></div></div><p>We can also simulate the policy. Note that this time, the simulation is stochastic. One common approach to quantify the quality of the policy is to perform  a Monte Carlo simulation and then form a confidence interval for the expected cost. This confidence interval is an estimate for the upper bound.</p><p>In addition to the confidence interval, we can calculate the lower bound using <a href="../../apireference/#Kokako.calculate_bound"><code>Kokako.calculate_bound</code></a>.</p><pre><code class="language-julia">simulations = Kokako.simulate(model, 500)

objective_values = [
    sum(stage[:stage_objective] for stage in sim) for sim in simulations
]

using Statistics

μ = round(mean(objective_values), digits = 2)
ci = round(1.96 * std(objective_values) / sqrt(500), digits = 2)

println(&quot;Confidence interval: &quot;, μ, &quot; ± &quot;, ci)
println(&quot;Lower bound: &quot;, round(Kokako.calculate_bound(model), digits = 2))

# output

Confidence interval: 8400.00 ± 409.34
Lower bound: 8333.33</code></pre><p>In addition to simulating the primal values of variables, we can also pass <code>Kokako.jl</code> custom recorder functions. Each of these functions takes one argument, the JuMP subproblem, and returns anything you can compute. For example, the dual of the demand constraint (which we named <code>demand_constraint</code>) corresponds to the price we should charge for electricity, since it represents the cost of each additional unit of demand. To calculate this, we can go</p><pre><code class="language-julia">simulations = Kokako.simulate(
    model,
    1,
    custom_recorders = Dict{Symbol, Function}(
        :price =&gt; (sp) -&gt; JuMP.dual(sp[:demand_constraint])
    )
)

electricity_price = [stage[:price] for stage in simulations[1]]

# output

3-element Array{Float64,1}:
  50.0
 100.0
  -0.0</code></pre><p>This concludes our second tutorial for <code>Kokako.jl</code>. In the next tutorial, <a href="../03_objective_uncertainty/#Basics-III:-objective-uncertainty-1">Basics III: objective uncertainty</a>, we extend the uncertainty to the fuel cost.</p><footer><hr/><a class="previous" href="../01_first_steps/"><span class="direction">Previous</span><span class="title">Basics I: first steps</span></a><a class="next" href="../03_objective_uncertainty/"><span class="direction">Next</span><span class="title">Basics III: objective uncertainty</span></a></footer></article></body></html>
